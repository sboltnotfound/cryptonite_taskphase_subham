# Crossed Wires
pretty good problem. So essentially we were given N,e,D private and public key for me, but the friends instead of using my public key they used their own, so one message got encrypted several times by 5 friend's public keys [pair of N and e],N was same for all, so with my private key info i had to figure out phi(N), i did that with the help of https://www.di-mgt.com.au/rsa_factorize_n.html, which used the point that m*phi(n) = d*e - 1 and phi(n) is always even so d*e - 1 is of the form k=2^t*r, where r is a odd integer. Now lets take a random number g^k whose modulo N is 1. Now with the help of Chinese remainder theorem, square root or g^k/2 modulo N or essentially the square roots of 1 modulo N has 4 possibilities, +1,-1,+x,-x where x satisfies x = 1 mod(p) & x=-1 mod(q), hence with this information we just need to get a 'g' (we can get g by randomly choosing it) which is able to give a 'x' square root, as then we can simply calculate gcd(x-1,N) why? coz x-1 would be a factor of p, even if we do gcd(x+1,N) that would also work [we would get q here]. Now we got one factor, we can obviously get the other factor by diving it on N. Next steps are quite simple, just do msg=msg^d mod(N), where d is congruent to e^-1 mod(phi(N)), which can be calculated using Euclidean extended gcd algorithm, and this step is repeated for all 5 friends to get back the original message.

# Square eyes
pretty simple here N=p^2, so apply the classic msg = msg^d mod(N), where d is congruent to e^-1 mod(N) which can be calculated using Euclidean extended gcd algorithm. the only difference would be in the calculation of Eulers tortient which will be p*(p-1) or N-sqrt(N), so instead of requiring to find factors, we just square root it.

